High CPU问题
1. 执行 procdump -c 50 -s 4 -ma -n 3 w3wp    命令含义为:当w3wp.exe  cpu超过50%,并且持续4秒，抓取3个dump文件存储起来，存储位置默认为procdump文件所在的目录。
2. !threadpool  查看线程池CPU使用量
3. !runaway 命令  看线程占用CPU时间
4. ~线程IDs 跳转到那个线程
5. !clrstack 看看这个线程再干嘛 执行那些方法

Memory Leak：
1. !eeheap，查看托管堆的总信息,看来大对象堆占用最多内存
2. !dumpheap -min 200 -stat 获取占用堆内存的各对象的统计信息, 查看堆中信息，一般带-min,-stat,-type等参数。看来Byte数组类型占用最多内存
3. !dumpheap -type Byte[] -min 200 看各Byte数组占用堆内存的详细信息
4. !gcroot <Byte数组对象地址> 看对象引用关系，跟踪到Program类的List类型成员了
5. !do <Program对象地址> 查看对象的详细信息。 就是_list了。有源代码文件的话这一步其实就可以略过，就算没有源代码文件也可以利用!dumpdomain与!SaveModule命令导出模块，然后使用Reflector进行反编译。

!dumpdomain,显示所有域里的程序集，或者根据参数获取指定域。
!savemodule,根据具体程序集地址，把当前程序集的代码生成到指定文件
!dumpheap -mt MTAddress   可以知道在MethodTable中相关联的所有instance。
!dso命令打印出栈上对应的Objects.
command /?  // 打印命令command具体参数用法
lmvm clr  查看CLR调试版本


windbg命令分为标准命令，元命令和扩展命令。
直接回车可重复执行上一条命令， Tab键进行命令补全， ;分隔符输入多条命令，  Ctrl + Break来终止
左下角显示 进程:线程
按Ctrl + Alt + V开启/关闭verbose Output（详细输出模式）
字典类不是线程安全的，导致CPU100%，使用了.net4.0提供的线程安全的字典类 ConcurrentDictionary  也可以使用lock解决~


1. 查询到待打断点的对象的MethodTable
2. 查看此MethodTable函数详细信息
3. 在需要打断点的函数上打算断点
4. 运行代码直到断点停下然后查看堆栈
5. 我要在函数的中间打断点，因此需要反汇编当前断点函数，然后在函数中间打断点
7. 在断点停下后，查看当前堆栈来取得待查参数的值


1. 查询到函数地址
0:025> !Name2EE Sobey.MAM.SystemUI.Controls.dll

2. 查看函数
0:025> !dumpmt -md 0x06847e78

3. 打断点
0:025> bp 0x0687e6c0
0:025> g

4. 查看堆栈
0:000> !clrstack

5.反汇编当前断点
0:000> !u eip

6.在汇编代码处打上断点
0:000> bp 0687e6e1 
0:000> g

7. 查看当前堆栈信息，然后就可以检查堆栈上的参数
0:000> !dso

8. 查看当前参数的值
0:000> !dc 0x1210e90

===========================================================
无意中在资源监视器的CPU页看到软件的线程数是1.7万个，内存页的提交内存使用也将近18G，同时线程数与提交内存也在缓慢增加。当时就想是不是由于某种原因导致线程无法退出从而在线程数太多的时候致使软件不响应请求（后来的调试也证实是死锁导致的）。

   由于故障难以重现（只在生产环境中长时间运行才会出现，在测试环境无法出现），只能对正在运行的软件进行分析。
   
   使用“~17306s”命令切换到最后一个线程，并使用“!clrstack”命令输出当前线程的调用堆栈，发现存在“System.Threading.Monitor.Enter(System.Object)”，表明线程正在请求一个锁。由于得不到锁，因此线程卡死



   切换到其它线程查看调用堆栈，都是因为同样的原因导致线程卡死，这时候可以初步判断这些线程是因为死锁导致执行不下去

   使用“!syncblk”命令列出所有正在使用的锁，其中MonitorHeld与Recursion列表示了请求锁的线程数量情况，Info列表示哪个线程拥有了锁，SyncBlock列表示锁对象的地址。如MonitorHeld与Recursion的值为3775与1那行表示第40个线程拥有了这个锁，其它(3775-1)/2=1887个线程在等待锁，锁对象地址为0000000003c812f0。看到如此多的线程在请求同一个锁，就知道情况不正常，看来离死锁的真相又近了一步
   
    接下来的过程就是：找到某个线程（如线程A）请求的锁（如锁J），查看哪个线程（如线程B）拥有这个锁（锁J）及这个线程请求的锁（锁K），接着查看哪个线程（如线程C）拥有这个锁（锁K）及这个线程请求的锁（锁L），重复查看的过程，看最终是否有一个线程（如线程D）请求前面出现的任意一个锁（如线程B拥有的锁J），形成环状，这时即可判断其为死锁
	
	这里从线程17306开始分析，使用“!clrstack -l”命令列出当前线程的调用堆栈及其使用的局部变量

   在调用“System.Threading.Monitor.Enter(System.Object)”之前的一个方法内，应该存在作为局部变量的线程请求的锁对象

   这里猜测下面的0000000003c812f0就是这个锁对象，通过查找上面的锁列表，确定了这个猜测，同时知道线程40拥有这个锁
   
    使用“~40s”命令切换到线程40，并使用“!clrstack -l”命令列出当前线程的调用堆栈及其使用的局部变量，通过查找锁列表确定000000000317ac10为当前线程请求的锁对象，同时知道线程26拥有这个锁
	
=======================================================================


SOS.dll MSCOREE.dll
Son of Strike, COM COR EE
